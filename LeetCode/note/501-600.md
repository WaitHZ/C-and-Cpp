# LeetCode 501-600



## 506.相对名词(简单)

https://leetcode.cn/problems/relative-ranks/description/

```c
#define MAXN 15

char* numToStr(int num) {
    int num_copy, count;
    char *str;

    if(num == 0) {
        str = (char*)malloc(sizeof(char)*2);

        str[0] = '0';
        str[1] = '\0';

        return str;
    }

    count = 0;
    num_copy = num;

    while(num) {
        count += 1;
        num /= 10;
    }

    str = (char*)malloc(sizeof(char)*(count+1));
    str[count] = '\0';

    for(int i = count-1; i >= 0; i--) {
        str[i] = '0' + num_copy % 10;
        num_copy /= 10;
    }

    return str;
}

void shellSort(int *arr, int size) {
    int gap;
    
    gap = 1;
    while(gap < size/3) {
        gap = gap * 3 + 1;
    }
    
    while(gap > 0) {
        for(int i = gap; i < size; i++) {
            int currentNum, index, current_rank;
            
            currentNum = arr[i];
            index = i - gap;
            while(index >= 0 && arr[index] < currentNum) {
                arr[index+gap] = arr[index];
                index -= gap;
            }
            arr[index+gap] = currentNum;
        }
        gap = (gap - 1) / 3;
    }
}

char ** findRelativeRanks(int* score, int scoreSize, int* returnSize){
    char **retArr, *tmp;
    int hash_table[1000001], *score_cp;

    for(int i = 0; i < 10001; i++) {
        hash_table[i] = 0;
    }

    score_cp = (int*)malloc(sizeof(int)*scoreSize);
    for(int i = 0; i < scoreSize; i++) {
        score_cp[i] = score[i];
    }
    
    shellSort(score, scoreSize);

    for(int i = 0; i < scoreSize; i++) {
        hash_table[score[i]] = i+1;
    }

    retArr = (char**)malloc(sizeof(char*)*scoreSize);

    for(int i = 0; i < scoreSize; i++) {
        int rank = hash_table[score_cp[i]];

        retArr[i] = (char*)malloc(sizeof(char)*MAXN);

        switch(rank) {
            case 1: strcpy(retArr[i], "Gold Medal"); break;
            case 2: strcpy(retArr[i], "Silver Medal"); break;
            case 3: strcpy(retArr[i], "Bronze Medal"); break;
            default: tmp = numToStr(rank); strcpy(retArr[i], tmp); free(tmp);
        }
    }

    *returnSize = scoreSize;

    free(score_cp);

    return retArr;
}
```

未正确使用哈希表，仅是借用了哈希的思想，因此空间复杂度过高。



## 509.斐波那契数(简单)

https://leetcode.cn/problems/fibonacci-number/description/

```c
int fib_arr[31] = {0, 1};

int fib(int n){
    int fact1, fact2;

    if(n < 2) {
        return n;
    }
    else {
        fact1 = fib_arr[n-1] > 0 ? fib_arr[n-1] : (fib_arr[n-1] = fib(n-1));
        fact2 = fib_arr[n-2] > 0 ? fib_arr[n-2] : (fib_arr[n-2] = fib(n-2));
    }

    return fact1 + fact2;
}
```



## 547.省份数量(中等)

https://leetcode.cn/problems/number-of-provinces/description/

```c
void UnionFind(int *root, int *rank, int size) {
    for(int i = 0; i < size; i++) {
        rank[i] = 1;
        root[i] = i;
    }
}

int find(int *root, int ind) {
    if(root[ind] != ind) {
        root[ind] = find(root, root[ind]);
    }

    return root[ind];
}

void union_by_rank(int *root, int *rank, int ind1, int ind2, int *count) {
    int root1, root2;

    root1 = find(root, ind1);
    root2 = find(root, ind2);

    if(root1 != root2) {
        if(rank[root1] > rank[root2]) {
            root[root2] = root1;
        }
        else if(rank[root1] < rank[root2]) {
            root[root1] = root2;
        }
        else {
            root[root2] = root1;
            rank[root1] += 1;
        }

        *count -= 1;
    }
}

bool isConnected(int *root, int ind1, int ind2) {
    return find(root, ind1) == find(root, ind2);
}

int findCircleNum(int** isConnected, int isConnectedSize, int* isConnectedColSize) {
    int *rank, *root, count;

    count = isConnectedSize;

    root = (int*)malloc(sizeof(int)*isConnectedSize);
    rank = (int*)malloc(sizeof(int)*isConnectedSize);

    UnionFind(root, rank, isConnectedSize);

    for(int i = 0; i < isConnectedSize; i++) {
        for(int j = 1; j < isConnectedSize; j++) {
            if(isConnected[i][j]) {
                union_by_rank(root, rank, i, j, &count);
            }
        }
    }

    free(root);
    free(rank);

    return count;
}
```

**一次有效合并就意味着省份数量-1.**
