# LeetCode 201-300



## 202.快乐数(简单)

https://leetcode.cn/problems/happy-number/description/

```c
bool isHappy(int n) {
    int square_sum;

    if(n == 1) {
        return true;
    }
    else if(n < 10 && n % 2 == 0) {
        return false;
    }
    else {
        square_sum = 0;

        while(n) {
            square_sum += (n % 10) * (n % 10);
            n /= 10;
        }

        return isHappy(square_sum);
    }
}
```



## 204.计数质数(中等)

https://leetcode.cn/problems/count-primes/description/

```c
int countPrimes(int n) {
    char *prime_arr;
    int prime_count;

    prime_arr = (char*)malloc(sizeof(char)*n);

    for(int i = 1; i < n; i++) {
        prime_arr[i] = 1;
    }

    for(int i = 2; i < sqrt(n); i++) {
        for(int j = i*i; j < n; j += i) {
            prime_arr[j] = 0;
        }
    }

    prime_count = 0;

    for(int i = 2; i < n; i++) {
        if(prime_arr[i]) {
            prime_count += 1;
        }
    }

    return prime_count;
}
```

方法称为埃氏筛，时间复杂度为$O(nlog(logn))$.



## 207.课程表(中等)

https://leetcode.cn/problems/course-schedule/description/

```c
typedef struct node *PtrToNode;
struct node {
    int vertax;
    PtrToNode next;
};
typedef PtrToNode *Graph;

struct QNode {
    int QArr[2001];
    int font, end;
};
typedef struct QNode *Queue;

Queue makeQueue() {
    Queue q;

    q = (Queue)malloc(sizeof(struct QNode));
    q->font = q->end = 0;

    return q;
}

bool isEmptyQueue(Queue q) {
    return q->font == q->end;
}

void enQueue(Queue q, int val) {
    (q->QArr)[++q->end] = val;
}

int deQueue(Queue q) {
    return (q->QArr)[++q->font];
}

bool canFinish(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize){
    Graph courses_graph;
    int course, pre_course, *in_degrees, count;
    PtrToNode new_node, ptr, tmp_ptr;
    Queue q;
    bool retVal;

    count = 0;
    retVal = true;

    courses_graph = (Graph)malloc(sizeof(PtrToNode)*numCourses);
    in_degrees = (int*)malloc(sizeof(int)*numCourses);

    for(int i = 0; i < numCourses; i++) {
        courses_graph[i] = NULL;
        in_degrees[i] = 0;
    }

    for(int i = 0; i < prerequisitesSize; i++) {
        pre_course = prerequisites[i][1];
        course = prerequisites[i][0];

        in_degrees[course] += 1;

        new_node = (PtrToNode)malloc(sizeof(struct node));
        new_node->vertax = course;
        new_node->next = courses_graph[pre_course];
        courses_graph[pre_course] = new_node;
    }

    q = makeQueue();

    for(int i = 0; i < numCourses; i++) {
        if(in_degrees[i] == 0) {
            enQueue(q, i);
            in_degrees[i] = -1;
        }
    }

    while(!isEmptyQueue(q)) {
        course = deQueue(q);
        count += 1;

        ptr = courses_graph[course];

        while(ptr) {
            in_degrees[ptr->vertax] -= 1;
            ptr = ptr->next;
        }

        courses_graph[course] = NULL;

        for(int i = 0; i < numCourses; i++) {
            if(in_degrees[i] == 0) {
                enQueue(q, i);
                in_degrees[i] = -1;
            }
        }
    }

    if(count < numCourses) {
        retVal = false;
    }

    free(in_degrees);
    for(int i = 0; i < numCourses; i++) {
        ptr = courses_graph[i];

        while(ptr) {
            tmp_ptr = ptr;
            ptr = ptr->next;
            free(tmp_ptr);
        }
    }

    free(courses_graph);

    return retVal;
}
```



## 210.课程表Ⅱ(中等)

https://leetcode.cn/problems/course-schedule-ii/description/

```c
typedef struct node *PtrToNode;
struct node {
    int vertax;
    PtrToNode next;
};
typedef PtrToNode *Graph;

struct QNode {
    int QArr[2001];
    int font, end;
};
typedef struct QNode *Queue;

Queue makeQueue() {
    Queue q;

    q = (Queue)malloc(sizeof(struct QNode));
    q->font = q->end = 0;

    return q;
}

bool isEmptyQueue(Queue q) {
    return q->font == q->end;
}

void enQueue(Queue q, int val) {
    (q->QArr)[++q->end] = val;
}

int deQueue(Queue q) {
    return (q->QArr)[++q->font];
}

int* findOrder(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize, int* returnSize){
    Graph courses_graph;
    int course, pre_course, *retArr, *in_degrees;
    PtrToNode new_node, ptr, tmp_ptr;
    Queue q;

    *returnSize = 0;

    courses_graph = (Graph)malloc(sizeof(PtrToNode)*numCourses);
    in_degrees = (int*)malloc(sizeof(int)*numCourses);

    for(int i = 0; i < numCourses; i++) {
        courses_graph[i] = NULL;
        in_degrees[i] = 0;
    }

    for(int i = 0; i < prerequisitesSize; i++) {
        pre_course = prerequisites[i][1];
        course = prerequisites[i][0];

        in_degrees[course] += 1;

        new_node = (PtrToNode)malloc(sizeof(struct node));
        new_node->vertax = course;
        new_node->next = courses_graph[pre_course];
        courses_graph[pre_course] = new_node;
    }

    retArr = (int*)malloc(sizeof(int)*numCourses);

    q = makeQueue();

    for(int i = 0; i < numCourses; i++) {
        if(in_degrees[i] == 0) {
            enQueue(q, i);
            in_degrees[i] = -1;
        }
    }

    while(!isEmptyQueue(q)) {
        course = deQueue(q);
        retArr[(*returnSize)++] = course;

        ptr = courses_graph[course];

        while(ptr) {
            in_degrees[ptr->vertax] -= 1;
            ptr = ptr->next;
        }

        courses_graph[course] = NULL;

        for(int i = 0; i < numCourses; i++) {
            if(in_degrees[i] == 0) {
                enQueue(q, i);
                in_degrees[i] = -1;
            }
        }
    }

    if(*returnSize < numCourses) {
        *returnSize = 0;
        free(retArr);
        retArr = NULL;
    }

    free(in_degrees);
    for(int i = 0; i < numCourses; i++) {
        ptr = courses_graph[i];

        while(ptr) {
            tmp_ptr = ptr;
            ptr = ptr->next;
            free(tmp_ptr);
        }
    }

    free(courses_graph);

    return retArr;
}
```



## 215.数组中的第K个最大元素(中等)

https://leetcode.cn/problems/kth-largest-element-in-an-array/description/

```c
void swap(int *arr, int i, int j) {
    int tmp;
    
    tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

void maxHeapify(int *arr, int size, int index) {
    int max_index, left, right;
    
    max_index = index;
    left = (index << 1) + 1;
    right = left + 1;
    
	max_index = left < size && arr[left] > arr[max_index] ? left : max_index;
    max_index = right < size && arr[right] > arr[max_index] ? right : max_index;
    
    if(max_index != index) {
        swap(arr, index, max_index);
        maxHeapify(arr, size, max_index);
        // 递归，保证子树还是最大堆
    }  
}

void buildMaxHeap(int *arr, int size) {
    for(int i = (size >> 1) - 1; i >= 0; i--) {
        maxHeapify(arr, size, i);
    }
}

int findKthLargest(int* nums, int numsSize, int k){
    buildMaxHeap(nums, numsSize);

    for(int i = 0; i < k-1; i++) {
        swap(nums, 0, numsSize-1-i);
        maxHeapify(nums, numsSize-1-i, 0);
    }

    return nums[0];
}
```



## 231.2的幂(简单)

https://leetcode.cn/problems/power-of-two/description/

```c
bool isPowerOfTwo(int n) {
    if(n <= 0) {
        return false;
    }
    else {
        return (n & (n-1)) == 0 ? true : false;
    }

}
```

注意运算的优先级。



## 263.丑数(简单)

https://leetcode.cn/problems/ugly-number/description/

```c
bool isUgly(int n){
    bool is_ugly;

    is_ugly = false;

    if(n > 0) {
        while(n % 2 == 0) {
            n /= 2;
        }

        while(n % 3 == 0) {
            n /= 3;
        }

        while(n % 5 == 0) {
            n /= 5;
        }

        is_ugly = (n == 1);
    }

    return is_ugly;
}
```



## 268.丢失的数字(简单)

https://leetcode.cn/problems/missing-number/description/

```c
int missingNumber(int* nums, int numsSize){
    int *hash_table, mis_num;

    hash_table = (int*)malloc(sizeof(int)*(numsSize+1));
    for(int i = 0; i <= numsSize; i++) {
        hash_table[i] = 0;
    }

    for(int i = 0; i < numsSize; i++) {
        hash_table[nums[i]] += 1;
    }

    for(int i = 0; i <= numsSize; i++) {
        if(hash_table[i] == 0) {
            mis_num = i;
            break;
        }
    }

    return mis_num;
}
```



## 278.第一个错误的版本(简单)

https://leetcode.cn/problems/first-bad-version/description/

```c
int firstBadVersion(int n) {
    int left, right, mid, retVal;

    left = 1;
    right = n;

    if(isBadVersion(1))
        retVal = 1;
    else {
        while(left <= right) {
            mid = (right - left) / 2 + left;

            if(!isBadVersion(mid))
                left = mid + 1;
            else {
                if(!isBadVersion(mid-1)) {
                    retVal = mid;

                    break;
                }
                else
                    right = mid - 1;
            }
        }
    }

    return retVal;
}
```

需要注意，我们通过下方的代码来避免溢出：

```c
mid = (right - left) / 2 + left;
```

而不采用：

```c
mid = (left + right) / 2;
```



## 279.完全平方数(中等)

https://leetcode.cn/problems/perfect-squares/description/

```c
typedef short ElementType;
typedef int Position;

typedef struct {
    ElementType *queueArr;
    Position head, tail;
    int capacity;
} Queue;

Queue *makeNewQueue(int size) {
    Queue *newQueue;

    newQueue = (Queue*)malloc(sizeof(Queue));
    newQueue->queueArr = (ElementType*)malloc(sizeof(ElementType)*size);
    newQueue->capacity = size + 1;
    newQueue->head = newQueue->tail = 0;

    return newQueue;
}

bool isEmptyQueue(Queue *q) {
    return (q->head % q->capacity) == (q->tail % q->capacity);
}

bool isFullQueue(Queue *q) {
    return (q->head % q->capacity) == ((q->tail+1) % q->capacity);
}

void enQueue(Queue *q, ElementType val) {
    if(isFullQueue(q)) {
        printf("Queue is full!\n");
        abort();
    }

    (q->queueArr)[(q->tail+1)%(q->capacity)] = val;
    q->tail += 1;
}

ElementType deQueue(Queue *q) {
    if(isEmptyQueue(q)) {
        printf("Queue is empty!\n");
        abort();
    }

    return (q->queueArr)[(++(q->head))%(q->capacity)];
}

ElementType getHeadEle(Queue *q) {
    if(isEmptyQueue(q)) {
        printf("Queue is empty!\n");
        abort();
    }

    return (q->queueArr)[q->head%q->capacity];
}

int elementNumInQueue(Queue *q) {
    int eleNum;
    
    if(q->tail%q->capacity > q->head%q->capacity) {
        eleNum = q->tail%q->capacity - q->head%q->capacity;
    }
    else if(q->tail%q->capacity == q->head%q->capacity) {
        eleNum = 0;
    }
    else {
        eleNum = q->tail%q->capacity - q->head%q->capacity + q->capacity-1;
    }

    return eleNum;
}

void freeQueue(Queue *q) {
    free(q->queueArr);
    free(q);
}

int numSquares(int n) {
    Queue *q;
    int step, num, numInQueue;

    q = makeNewQueue(n*n/3+10);

    step = 0;

    enQueue(q, n);
    while(!isEmptyQueue(q)) {
        numInQueue = elementNumInQueue(q); 

        for(int i = 0; i < numInQueue; i++) {
            num = deQueue(q);

            if(num == 0) {
                freeQueue(q);
                return step;
            }

            for(int i = sqrt(num); i > 0; i--) {
                enQueue(q, num-i*i);
            }
        }

        step += 1;
    }

    freeQueue(q);

    return -1;
}
```

BFS算法求解最短路问题，在图较复杂时开销较大



## 283.移动零(简单)

https://leetcode.cn/problems/move-zeroes/description/

```c
void moveZeroes(int* nums, int numsSize) {
    bool swapped;
    int indexOfLastUnsortedEle, swapIndex;

    swapped = true;
    indexOfLastUnsortedEle = numsSize - 1;
    swapIndex = -1;

    while(swapped) {
        swapped = false;

        for(int i = 0; i < indexOfLastUnsortedEle; i++) {
            if(nums[i] == 0 && nums[i+1] != 0) {
                nums[i] = nums[i] ^ nums[i+1];
                nums[i+1] = nums[i] ^ nums[i+1];
                nums[i] = nums[i+1] ^ nums[i];

                swapped = true;
                swapIndex = i;
            }
        }

        indexOfLastUnsortedEle = swapIndex;
    }
}
```



## 286.墙与门(中等)

https://leetcode.cn/problems/walls-and-gates/description/

```c
typedef struct {
    int col, row;
} Point;

typedef Point ElementType;
typedef int Position;

typedef struct {
    ElementType *queueArr;
    Position head, tail;
    int capacity;
} Queue;

Queue *makeNewQueue(int size) {
    Queue *newQueue;

    newQueue = (Queue*)malloc(sizeof(Queue));
    newQueue->queueArr = (ElementType*)malloc(sizeof(ElementType)*(size+1));
    newQueue->capacity = size + 1;
    newQueue->head = newQueue->tail = 0;

    return newQueue;
}

bool isEmptyQueue(Queue *q) {
    return (q->head % q->capacity) == (q->tail % q->capacity);
}

bool isFullQueue(Queue *q) {
    return (q->head % q->capacity) == ((q->tail+1) % q->capacity);
}

void enQueue(Queue *q, ElementType val) {
    if(isFullQueue(q)) {
        printf("Queue is full!\n");
        abort();
    }

    (q->queueArr)[(++(q->tail))%(q->capacity)] = val;
}

ElementType deQueue(Queue *q) {
    if(isEmptyQueue(q)) {
        printf("Queue is empty!\n");
        abort();
    }

    return (q->queueArr)[(++(q->head))%(q->capacity)];
}

ElementType getHeadEle(Queue *q) {
    if(isEmptyQueue(q)) {
        printf("Queue is empty!\n");
        abort();
    }

    return (q->queueArr)[q->head%q->capacity];
}

int elementNumInQueue(Queue *q) {
    int eleNum;
    
    if(q->tail%q->capacity > q->head%q->capacity) {
        eleNum = q->tail%q->capacity - q->head%q->capacity;
    }
    else if(q->tail%q->capacity == q->head%q->capacity) {
        eleNum = 0;
    }
    else {
        eleNum = q->tail%q->capacity - q->head%q->capacity + q->capacity-1;
    }

    return eleNum;
}

void freeQueue(Queue *q) {
    free(q->queueArr);
    free(q);
}

void wallsAndGates(int** rooms, int roomsSize, int* roomsColSize){
    bool **havePassed;
    int step, numInQueue;
    Queue *q;
    Point p, p_new;

    havePassed = (bool**)malloc(sizeof(bool*)*roomsSize);
    for(int i = 0; i < roomsSize; i++) {
        havePassed[i] = (bool*)malloc(sizeof(bool)*roomsColSize[i]);
    }

    for(int i = 0; i < roomsSize; i++) {
        for(int j = 0; j < roomsColSize[i]; j++) {
            if(rooms[i][j] == 0) {

                for(int i = 0; i < roomsSize; i++) {
                    for(int j = 0; j < roomsColSize[i]; j++) {
                        havePassed[i][j] = false;
                    }
                }

                q = makeNewQueue(roomsSize*roomsColSize[i]);

                step = 0;

                p.col = i;
                p.row = j;
                havePassed[i][j] = true;
                enQueue(q, p);
                while(!isEmptyQueue(q)) {
                    numInQueue = elementNumInQueue(q);

                    for(int k = 0; k < numInQueue; k++) {
                        p = deQueue(q);
                        if(step < rooms[p.col][p.row]) {
                            rooms[p.col][p.row] = step;
                        }

                        if(p.col-1 >= 0 && rooms[p.col-1][p.row] > 0 && havePassed[p.col-1][p.row] == false) {
                            havePassed[p.col-1][p.row] = true;
                            p_new.col = p.col-1;
                            p_new.row = p.row;
                            enQueue(q, p_new);
                        }
                        if(p.row-1 >= 0 && rooms[p.col][p.row-1] > 0 && havePassed[p.col][p.row-1] == false) {
                            havePassed[p.col][p.row-1] = true;
                            p_new.col = p.col;
                            p_new.row = p.row-1;
                            enQueue(q, p_new);
                        }
                        if(p.col+1 < roomsSize && rooms[p.col+1][p.row] > 0 && havePassed[p.col+1][p.row] == false) {
                            havePassed[p.col+1][p.row] = true;
                            p_new.col = p.col+1;
                            p_new.row = p.row;
                            enQueue(q, p_new);
                        }
                        if(p.row+1 < roomsColSize[0] && rooms[p.col][p.row+1] > 0 && havePassed[p.col][p.row+1] == false) {
                            havePassed[p.col][p.row+1] = true;
                            p_new.col = p.col;
                            p_new.row = p.row+1;
                            enQueue(q, p_new);
                        }
                    }

                    step += 1;
                }

                freeQueue(q);
            }
        }
    }
}
```

