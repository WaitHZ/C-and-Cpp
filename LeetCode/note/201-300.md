# LeetCode 201-300



## 202.快乐数(简单)

https://leetcode.cn/problems/happy-number/description/

```c
bool isHappy(int n) {
    int square_sum;

    if(n == 1) {
        return true;
    }
    else if(n < 10 && n % 2 == 0) {
        return false;
    }
    else {
        square_sum = 0;

        while(n) {
            square_sum += (n % 10) * (n % 10);
            n /= 10;
        }

        return isHappy(square_sum);
    }
}
```



## 204.计数质数(中等)

https://leetcode.cn/problems/count-primes/description/

```c
int countPrimes(int n) {
    char *prime_arr;
    int prime_count;

    prime_arr = (char*)malloc(sizeof(char)*n);

    for(int i = 1; i < n; i++) {
        prime_arr[i] = 1;
    }

    for(int i = 2; i < sqrt(n); i++) {
        for(int j = i*i; j < n; j += i) {
            prime_arr[j] = 0;
        }
    }

    prime_count = 0;

    for(int i = 2; i < n; i++) {
        if(prime_arr[i]) {
            prime_count += 1;
        }
    }

    return prime_count;
}
```

方法称为埃氏筛，时间复杂度为$O(nlog(logn))$.



## 210.课程表Ⅱ(中等)

https://leetcode.cn/problems/course-schedule-ii/description/

```c
typedef struct node *PtrToNode;
struct node {
    int vertax;
    PtrToNode next;
};
typedef PtrToNode *Graph;

struct QNode {
    int QArr[2001];
    int font, end;
};
typedef struct QNode *Queue;

Queue makeQueue() {
    Queue q;

    q = (Queue)malloc(sizeof(struct QNode));
    q->font = q->end = 0;

    return q;
}

bool isEmptyQueue(Queue q) {
    return q->font == q->end;
}

void enQueue(Queue q, int val) {
    (q->QArr)[++q->end] = val;
}

int deQueue(Queue q) {
    return (q->QArr)[++q->font];
}

int* findOrder(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize, int* returnSize){
    Graph courses_graph;
    int course, pre_course, *retArr, *in_degrees;
    PtrToNode new_node, ptr, tmp_ptr;
    Queue q;

    *returnSize = 0;

    courses_graph = (Graph)malloc(sizeof(PtrToNode)*numCourses);
    in_degrees = (int*)malloc(sizeof(int)*numCourses);

    for(int i = 0; i < numCourses; i++) {
        courses_graph[i] = NULL;
        in_degrees[i] = 0;
    }

    for(int i = 0; i < prerequisitesSize; i++) {
        pre_course = prerequisites[i][1];
        course = prerequisites[i][0];

        in_degrees[course] += 1;

        new_node = (PtrToNode)malloc(sizeof(struct node));
        new_node->vertax = course;
        new_node->next = courses_graph[pre_course];
        courses_graph[pre_course] = new_node;
    }

    retArr = (int*)malloc(sizeof(int)*numCourses);

    q = makeQueue();

    for(int i = 0; i < numCourses; i++) {
        if(in_degrees[i] == 0) {
            enQueue(q, i);
            in_degrees[i] = -1;
        }
    }

    while(!isEmptyQueue(q)) {
        course = deQueue(q);
        retArr[(*returnSize)++] = course;

        ptr = courses_graph[course];

        while(ptr) {
            in_degrees[ptr->vertax] -= 1;
            ptr = ptr->next;
        }

        courses_graph[course] = NULL;

        for(int i = 0; i < numCourses; i++) {
            if(in_degrees[i] == 0) {
                enQueue(q, i);
                in_degrees[i] = -1;
            }
        }
    }

    if(*returnSize < numCourses) {
        *returnSize = 0;
        free(retArr);
        retArr = NULL;
    }

    free(in_degrees);
    for(int i = 0; i < numCourses; i++) {
        ptr = courses_graph[i];

        while(ptr) {
            tmp_ptr = ptr;
            ptr = ptr->next;
            free(tmp_ptr);
        }
    }

    free(courses_graph);

    return retArr;
}
```



## 231.2的幂(简单)

https://leetcode.cn/problems/power-of-two/description/

```c
bool isPowerOfTwo(int n) {
    if(n <= 0) {
        return false;
    }
    else {
        return (n & (n-1)) == 0 ? true : false;
    }

}
```

注意运算的优先级。



## 263.丑数(简单)

https://leetcode.cn/problems/ugly-number/description/

```c
bool isUgly(int n){
    bool is_ugly;

    is_ugly = false;

    if(n > 0) {
        while(n % 2 == 0) {
            n /= 2;
        }

        while(n % 3 == 0) {
            n /= 3;
        }

        while(n % 5 == 0) {
            n /= 5;
        }

        is_ugly = (n == 1);
    }

    return is_ugly;
}
```



## 268.丢失的数字(简单)

https://leetcode.cn/problems/missing-number/description/

```c
int missingNumber(int* nums, int numsSize){
    int *hash_table, mis_num;

    hash_table = (int*)malloc(sizeof(int)*(numsSize+1));
    for(int i = 0; i <= numsSize; i++) {
        hash_table[i] = 0;
    }

    for(int i = 0; i < numsSize; i++) {
        hash_table[nums[i]] += 1;
    }

    for(int i = 0; i <= numsSize; i++) {
        if(hash_table[i] == 0) {
            mis_num = i;
            break;
        }
    }

    return mis_num;
}
```



## 278.第一个错误的版本(简单)

https://leetcode.cn/problems/first-bad-version/description/

```c
int firstBadVersion(int n) {
    int left, right, mid, retVal;

    left = 1;
    right = n;

    if(isBadVersion(1))
        retVal = 1;
    else {
        while(left <= right) {
            mid = (right - left) / 2 + left;

            if(!isBadVersion(mid))
                left = mid + 1;
            else {
                if(!isBadVersion(mid-1)) {
                    retVal = mid;

                    break;
                }
                else
                    right = mid - 1;
            }
        }
    }

    return retVal;
}
```

需要注意，我们通过下方的代码来避免溢出：

```c
mid = (right - left) / 2 + left;
```

而不采用：

```c
mid = (left + right) / 2;
```



## 283.移动零(简单)

https://leetcode.cn/problems/move-zeroes/description/

```c
void moveZeroes(int* nums, int numsSize) {
    bool swapped;
    int indexOfLastUnsortedEle, swapIndex;

    swapped = true;
    indexOfLastUnsortedEle = numsSize - 1;
    swapIndex = -1;

    while(swapped) {
        swapped = false;

        for(int i = 0; i < indexOfLastUnsortedEle; i++) {
            if(nums[i] == 0 && nums[i+1] != 0) {
                nums[i] = nums[i] ^ nums[i+1];
                nums[i+1] = nums[i] ^ nums[i+1];
                nums[i] = nums[i+1] ^ nums[i];

                swapped = true;
                swapIndex = i;
            }
        }

        indexOfLastUnsortedEle = swapIndex;
    }
}
```

