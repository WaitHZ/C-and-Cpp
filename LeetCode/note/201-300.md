# LeetCode 201-300



## 202.快乐数(简单)

https://leetcode.cn/problems/happy-number/description/

```c
bool isHappy(int n) {
    int square_sum;

    if(n == 1) {
        return true;
    }
    else if(n < 10 && n % 2 == 0) {
        return false;
    }
    else {
        square_sum = 0;

        while(n) {
            square_sum += (n % 10) * (n % 10);
            n /= 10;
        }

        return isHappy(square_sum);
    }
}
```



## 204.计数质数(中等)

https://leetcode.cn/problems/count-primes/description/

```c
int countPrimes(int n) {
    char *prime_arr;
    int prime_count;

    prime_arr = (char*)malloc(sizeof(char)*n);

    for(int i = 1; i < n; i++) {
        prime_arr[i] = 1;
    }

    for(int i = 2; i < sqrt(n); i++) {
        for(int j = i*i; j < n; j += i) {
            prime_arr[j] = 0;
        }
    }

    prime_count = 0;

    for(int i = 2; i < n; i++) {
        if(prime_arr[i]) {
            prime_count += 1;
        }
    }

    return prime_count;
}
```

方法称为埃氏筛，时间复杂度为$O(nlog(logn))$.



## 231.2的幂(简单)

https://leetcode.cn/problems/power-of-two/description/

```c
bool isPowerOfTwo(int n) {
    if(n <= 0) {
        return false;
    }
    else {
        return (n & (n-1)) == 0 ? true : false;
    }

}
```

注意运算的优先级。



## 263.丑数(简单)

https://leetcode.cn/problems/ugly-number/description/

```c
bool isUgly(int n){
    bool is_ugly;

    is_ugly = false;

    if(n > 0) {
        while(n % 2 == 0) {
            n /= 2;
        }

        while(n % 3 == 0) {
            n /= 3;
        }

        while(n % 5 == 0) {
            n /= 5;
        }

        is_ugly = (n == 1);
    }

    return is_ugly;
}
```



## 268.丢失的数字(简单)

https://leetcode.cn/problems/missing-number/description/

```c
int missingNumber(int* nums, int numsSize){
    int *hash_table, mis_num;

    hash_table = (int*)malloc(sizeof(int)*(numsSize+1));
    for(int i = 0; i <= numsSize; i++) {
        hash_table[i] = 0;
    }

    for(int i = 0; i < numsSize; i++) {
        hash_table[nums[i]] += 1;
    }

    for(int i = 0; i <= numsSize; i++) {
        if(hash_table[i] == 0) {
            mis_num = i;
            break;
        }
    }

    return mis_num;
}
```



## 278.第一个错误的版本(简单)

https://leetcode.cn/problems/first-bad-version/description/

```c
int firstBadVersion(int n) {
    int left, right, mid, retVal;

    left = 1;
    right = n;

    if(isBadVersion(1))
        retVal = 1;
    else {
        while(left <= right) {
            mid = (right - left) / 2 + left;

            if(!isBadVersion(mid))
                left = mid + 1;
            else {
                if(!isBadVersion(mid-1)) {
                    retVal = mid;

                    break;
                }
                else
                    right = mid - 1;
            }
        }
    }

    return retVal;
}
```

需要注意，我们通过下方的代码来避免溢出：

```c
mid = (right - left) / 2 + left;
```

而不采用：

```c
mid 
```

