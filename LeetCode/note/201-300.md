# LeetCode 201-300



## 202.快乐数(简单)

https://leetcode.cn/problems/happy-number/description/

### 解法一：递归

```c
bool isHappy(int n) {
    int square_sum;

    if(n == 1) {
        return true;
    }
    else if(n < 10 && n % 2 == 0) {
        return false;
    }
    else {
        square_sum = 0;

        while(n) {
            square_sum += (n % 10) * (n % 10);
            n /= 10;
        }

        return isHappy(square_sum);
    }
}
```

### 解法二：哈希集合

```c
typedef int ElementType;
typedef int Position;

typedef struct LNode *PtrToLNode;
struct LNode {
    ElementType key;
    PtrToLNode next;
};
typedef PtrToLNode List;

typedef struct {
   List *buckets;
   int size; 
} HashSet;

Position HashFunc(ElementType key) {
	return key % 1000;
}

HashSet *makeNewHashSet(int size) {
	HashSet *newHashSet;

	newHashSet = (HashSet*)malloc(sizeof(HashSet));
	newHashSet->size = size;
	newHashSet->buckets = (PtrToLNode*)malloc(sizeof(struct ListNode)*size);
	memset(newHashSet->buckets, 0, sizeof(PtrToLNode)*size);

	return newHashSet;
}

bool HashSetContains(HashSet *s, ElementType key) {
	bool isContained;
	PtrToLNode ptr;

	isContained = false;
	ptr = (s->buckets)[HashFunc(key)];

	while(ptr) {
		if(ptr->key == key) {
			isContained = true;
			break;
		}
        ptr = ptr->next;
	}

	return isContained;
}

void HashSetAdd(HashSet *s, ElementType key) {
	PtrToLNode ptr;

	if(!HashSetContains(s, key)) {
		ptr = (s->buckets)[HashFunc(key)];
		(s->buckets)[HashFunc(key)] = (PtrToLNode)malloc(sizeof(struct ListNode));
		(s->buckets)[HashFunc(key)]->key = key;
		(s->buckets)[HashFunc(key)]->next = ptr;
	}
}

void HashSetRemove(HashSet *s, ElementType key) {
	PtrToLNode ptr, tmp;
    
    if(HashSetContains(s, key)) {
        ptr = (s->buckets)[HashFunc(key)];
        if(ptr->key == key) {
            (s->buckets)[HashFunc(key)] = ptr->next;
            free(ptr);
        }
        else {
            tmp = (s->buckets)[HashFunc(key)];
            ptr = ptr->next;
            while(ptr) {
                if(ptr->key == key) {
                    tmp->next = ptr->next;
                    free(ptr);
                    break;
                }
                tmp = ptr;
                ptr = ptr->next;
            }
        }
    }
}

void HashSetFree(HashSet* s) {
    PtrToLNode ptr1, ptr2;
    
    for(int i = 0; i < s->size; i++) {
        if((s->buckets)[i] != NULL) {
            ptr1 = (s->buckets)[i];
            while(ptr1) {
                ptr2 = ptr1->next;
                free(ptr1);
                ptr1 = ptr2;
            }
        }
    }

    free(s);
}

bool isHappy(int n){
    HashSet *s;
    int new_num;

    s = makeNewHashSet(1000);

    while(n != 1 && !HashSetContains(s, n)) {
        HashSetAdd(s, n);
        new_num = 0;
        while(n) {
            new_num = new_num + (n%10) * (n%10);
            n /= 10;
        }
        n = new_num;
    }

    return n == 1;
}
```



## 204.计数质数(中等)

https://leetcode.cn/problems/count-primes/description/

```c
int countPrimes(int n) {
    char *prime_arr;
    int prime_count;

    prime_arr = (char*)malloc(sizeof(char)*n);

    for(int i = 1; i < n; i++) {
        prime_arr[i] = 1;
    }

    for(int i = 2; i < sqrt(n); i++) {
        for(int j = i*i; j < n; j += i) {
            prime_arr[j] = 0;
        }
    }

    prime_count = 0;

    for(int i = 2; i < n; i++) {
        if(prime_arr[i]) {
            prime_count += 1;
        }
    }

    return prime_count;
}
```

方法称为埃氏筛，时间复杂度为$O(nlog(logn))$.



## 205.同构字符串(简单)

https://leetcode.cn/problems/isomorphic-strings/description/

```c
typedef char KeyType;
typedef char ValType;
typedef int Position;

typedef struct SetNode *PtrToSetNode;
struct SetNode {
    KeyType key;
    PtrToSetNode next;
};
typedef PtrToSetNode SetList;

typedef struct {
   SetList *buckets;
   int size; 
} HashSet;

Position HashFunc(KeyType key) {
	return (int)key;
}

HashSet *makeNewHashSet(int size) {
	HashSet *newHashSet;

	newHashSet = (HashSet*)malloc(sizeof(HashSet));
	newHashSet->size = size;
	newHashSet->buckets = (PtrToSetNode*)malloc(sizeof(struct SetNode)*size);
	memset(newHashSet->buckets, 0, sizeof(PtrToSetNode)*size);

	return newHashSet;
}

bool HashSetContains(HashSet *s, KeyType key) {
	bool isContained;
	PtrToSetNode ptr;

	isContained = false;
	ptr = (s->buckets)[HashFunc(key)];

	while(ptr) {
		if(ptr->key == key) {
			isContained = true;
			break;
		}
        ptr = ptr->next;
	}

	return isContained;
}

void HashSetAdd(HashSet *s, KeyType key) {
	PtrToSetNode ptr;

	if(!HashSetContains(s, key)) {
		ptr = (s->buckets)[HashFunc(key)];
		(s->buckets)[HashFunc(key)] = (PtrToSetNode)malloc(sizeof(struct SetNode));
		(s->buckets)[HashFunc(key)]->key = key;
		(s->buckets)[HashFunc(key)]->next = ptr;
	}
}

void HashSetRemove(HashSet *s, KeyType key) {
	PtrToSetNode ptr, tmp;
    
    if(HashSetContains(s, key)) {
        ptr = (s->buckets)[HashFunc(key)];
        if(ptr->key == key) {
            (s->buckets)[HashFunc(key)] = ptr->next;
            free(ptr);
        }
        else {
            tmp = (s->buckets)[HashFunc(key)];
            ptr = ptr->next;
            while(ptr) {
                if(ptr->key == key) {
                    tmp->next = ptr->next;
                    free(ptr);
                    break;
                }
                tmp = ptr;
                ptr = ptr->next;
            }
        }
    }
}

void HashSetFree(HashSet* s) {
    PtrToSetNode ptr1, ptr2;
    
    for(int i = 0; i < s->size; i++) {
        if((s->buckets)[i] != NULL) {
            ptr1 = (s->buckets)[i];
            while(ptr1) {
                ptr2 = ptr1->next;
                free(ptr1);
                ptr1 = ptr2;
            }
        }
    }

    free(s);
}

typedef struct MapNode *PtrToMapNode;
struct MapNode {
    KeyType key;
    ValType val;
    PtrToMapNode next;
};
typedef PtrToMapNode MapList;

typedef struct {
    MapList *buckets;
    int size;
} HashMap;

HashMap *makeNewHashMap(int size) {
    HashMap *newHashMap;

    newHashMap = (HashMap*)malloc(sizeof(HashMap));
    newHashMap->size = size;
    newHashMap->buckets = (MapList*)malloc(sizeof(struct MapNode)*size);
    memset(newHashMap->buckets, 0, sizeof(PtrToMapNode)*size);

    return newHashMap;
}

bool HashMapContains(HashMap *m, KeyType key) {
    PtrToMapNode ptr;
    bool contain;

    contain = false;
    ptr = (m->buckets)[HashFunc(key)];
    while(ptr) {
        if(ptr->key == key) {
            contain = true;
            break;
        }
        ptr = ptr->next;
    }

    return contain;
}

ValType HashMapGet(HashMap* m, KeyType key) {
    PtrToMapNode ptr;
    ValType val;

    ptr = (m->buckets)[HashFunc(key)];
    while(ptr) {
        if(ptr->key == key) {
            val = ptr->val;
            break;
        }
        ptr = ptr->next;
    }

    return val;
}

void HashMapPut(HashMap* m, KeyType key, ValType value) {
    PtrToMapNode ptr;
    
    ptr = (m->buckets)[HashFunc(key)];
    if(HashMapContains(m, key)) {
        while(ptr) {
            if(ptr->key == key) {
                ptr->val = value;
                break;
            } 
            ptr = ptr->next;
        }
    }
    else {
        (m->buckets)[HashFunc(key)] = (PtrToMapNode)malloc(sizeof(struct MapNode));
        (m->buckets)[HashFunc(key)]->next = ptr;
        (m->buckets)[HashFunc(key)]->val = value;
        (m->buckets)[HashFunc(key)]->key = key;
    }
}

void HashMapRemove(HashMap *m, ValType key) {
    PtrToMapNode ptr1, ptr2;
    
    if(HashMapContains(m, key)) {
        ptr1 = (m->buckets)[HashFunc(key)];
        if(ptr1->key == key) {
            (m->buckets)[HashFunc(key)] = ptr1->next;
        }
        else {
            ptr2 = ptr1;
            ptr1 = ptr1->next;
            while(ptr1) {
                if(ptr1->key == key) {
                    ptr2->next = ptr1->next;
                    free(ptr1);
                }
                ptr2 = ptr1;
                ptr1 = ptr1->next;
            }
        }
    }
}

void HashMapFree(HashMap* m) {
    PtrToMapNode ptr1, ptr2;

    for(int i = 0; i < m->size; i++) {
        if((m->buckets)[i] != NULL) {
            ptr1 = (m->buckets)[i];
            while(ptr1) {
                ptr2 = ptr1->next;
                free(ptr1);
                ptr1 = ptr2;
            }
        }
    }

    free(m);
}

bool isIsomorphic(char * s, char * t){
    HashMap *m;
    HashSet *set;
    bool retVal;

    m = makeNewHashMap(128);
    set = makeNewHashSet(128);

    retVal = true;
    for(int i = 0; s[i]; i++) {
        if(HashMapContains(m, s[i])) {
            if(HashMapGet(m, s[i]) != t[i]) {
                retVal = false;
                break;
            }
        }
        else {
            if(HashSetContains(set, t[i])) {
                retVal = false;
                break;
            }
            HashMapPut(m, s[i], t[i]);
            HashSetAdd(set, t[i]);
        }
    }

    return retVal;
}
```

题目描述的关系并非双射关系，需要同时应用映射和集合



## 207.课程表(中等)

https://leetcode.cn/problems/course-schedule/description/

```c
typedef struct node *PtrToNode;
struct node {
    int vertax;
    PtrToNode next;
};
typedef PtrToNode *Graph;

struct QNode {
    int QArr[2001];
    int font, end;
};
typedef struct QNode *Queue;

Queue makeQueue() {
    Queue q;

    q = (Queue)malloc(sizeof(struct QNode));
    q->font = q->end = 0;

    return q;
}

bool isEmptyQueue(Queue q) {
    return q->font == q->end;
}

void enQueue(Queue q, int val) {
    (q->QArr)[++q->end] = val;
}

int deQueue(Queue q) {
    return (q->QArr)[++q->font];
}

bool canFinish(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize){
    Graph courses_graph;
    int course, pre_course, *in_degrees, count;
    PtrToNode new_node, ptr, tmp_ptr;
    Queue q;
    bool retVal;

    count = 0;
    retVal = true;

    courses_graph = (Graph)malloc(sizeof(PtrToNode)*numCourses);
    in_degrees = (int*)malloc(sizeof(int)*numCourses);

    for(int i = 0; i < numCourses; i++) {
        courses_graph[i] = NULL;
        in_degrees[i] = 0;
    }

    for(int i = 0; i < prerequisitesSize; i++) {
        pre_course = prerequisites[i][1];
        course = prerequisites[i][0];

        in_degrees[course] += 1;

        new_node = (PtrToNode)malloc(sizeof(struct node));
        new_node->vertax = course;
        new_node->next = courses_graph[pre_course];
        courses_graph[pre_course] = new_node;
    }

    q = makeQueue();

    for(int i = 0; i < numCourses; i++) {
        if(in_degrees[i] == 0) {
            enQueue(q, i);
            in_degrees[i] = -1;
        }
    }

    while(!isEmptyQueue(q)) {
        course = deQueue(q);
        count += 1;

        ptr = courses_graph[course];

        while(ptr) {
            in_degrees[ptr->vertax] -= 1;
            ptr = ptr->next;
        }

        courses_graph[course] = NULL;

        for(int i = 0; i < numCourses; i++) {
            if(in_degrees[i] == 0) {
                enQueue(q, i);
                in_degrees[i] = -1;
            }
        }
    }

    if(count < numCourses) {
        retVal = false;
    }

    free(in_degrees);
    for(int i = 0; i < numCourses; i++) {
        ptr = courses_graph[i];

        while(ptr) {
            tmp_ptr = ptr;
            ptr = ptr->next;
            free(tmp_ptr);
        }
    }

    free(courses_graph);

    return retVal;
}
```



## 210.课程表Ⅱ(中等)

https://leetcode.cn/problems/course-schedule-ii/description/

```c
typedef struct node *PtrToNode;
struct node {
    int vertax;
    PtrToNode next;
};
typedef PtrToNode *Graph;

struct QNode {
    int QArr[2001];
    int font, end;
};
typedef struct QNode *Queue;

Queue makeQueue() {
    Queue q;

    q = (Queue)malloc(sizeof(struct QNode));
    q->font = q->end = 0;

    return q;
}

bool isEmptyQueue(Queue q) {
    return q->font == q->end;
}

void enQueue(Queue q, int val) {
    (q->QArr)[++q->end] = val;
}

int deQueue(Queue q) {
    return (q->QArr)[++q->font];
}

int* findOrder(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize, int* returnSize){
    Graph courses_graph;
    int course, pre_course, *retArr, *in_degrees;
    PtrToNode new_node, ptr, tmp_ptr;
    Queue q;

    *returnSize = 0;

    courses_graph = (Graph)malloc(sizeof(PtrToNode)*numCourses);
    in_degrees = (int*)malloc(sizeof(int)*numCourses);

    for(int i = 0; i < numCourses; i++) {
        courses_graph[i] = NULL;
        in_degrees[i] = 0;
    }

    for(int i = 0; i < prerequisitesSize; i++) {
        pre_course = prerequisites[i][1];
        course = prerequisites[i][0];

        in_degrees[course] += 1;

        new_node = (PtrToNode)malloc(sizeof(struct node));
        new_node->vertax = course;
        new_node->next = courses_graph[pre_course];
        courses_graph[pre_course] = new_node;
    }

    retArr = (int*)malloc(sizeof(int)*numCourses);

    q = makeQueue();

    for(int i = 0; i < numCourses; i++) {
        if(in_degrees[i] == 0) {
            enQueue(q, i);
            in_degrees[i] = -1;
        }
    }

    while(!isEmptyQueue(q)) {
        course = deQueue(q);
        retArr[(*returnSize)++] = course;

        ptr = courses_graph[course];

        while(ptr) {
            in_degrees[ptr->vertax] -= 1;
            ptr = ptr->next;
        }

        courses_graph[course] = NULL;

        for(int i = 0; i < numCourses; i++) {
            if(in_degrees[i] == 0) {
                enQueue(q, i);
                in_degrees[i] = -1;
            }
        }
    }

    if(*returnSize < numCourses) {
        *returnSize = 0;
        free(retArr);
        retArr = NULL;
    }

    free(in_degrees);
    for(int i = 0; i < numCourses; i++) {
        ptr = courses_graph[i];

        while(ptr) {
            tmp_ptr = ptr;
            ptr = ptr->next;
            free(tmp_ptr);
        }
    }

    free(courses_graph);

    return retArr;
}
```



## 215.数组中的第K个最大元素(中等)

https://leetcode.cn/problems/kth-largest-element-in-an-array/description/

```c
void swap(int *arr, int i, int j) {
    int tmp;
    
    tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

void maxHeapify(int *arr, int size, int index) {
    int max_index, left, right;
    
    max_index = index;
    left = (index << 1) + 1;
    right = left + 1;
    
	max_index = left < size && arr[left] > arr[max_index] ? left : max_index;
    max_index = right < size && arr[right] > arr[max_index] ? right : max_index;
    
    if(max_index != index) {
        swap(arr, index, max_index);
        maxHeapify(arr, size, max_index);
        // 递归，保证子树还是最大堆
    }  
}

void buildMaxHeap(int *arr, int size) {
    for(int i = (size >> 1) - 1; i >= 0; i--) {
        maxHeapify(arr, size, i);
    }
}

int findKthLargest(int* nums, int numsSize, int k){
    buildMaxHeap(nums, numsSize);

    for(int i = 0; i < k-1; i++) {
        swap(nums, 0, numsSize-1-i);
        maxHeapify(nums, numsSize-1-i, 0);
    }

    return nums[0];
}
```



## 217.存在重复元素(简单)

https://leetcode.cn/problems/contains-duplicate/description/

### 解法一：基数排序

```c
typedef int ElementType;

int getIntVal(ElementType a) {
    return a;
}

int absVal(int x) {
    return x < 0 ? -x : x;
}

void radixSort(ElementType *arr, int arrSize, int(*getIntVal)(ElementType a)) {
    int max = 0, maxDigitLength, count[19], radix;
    long dev;
    ElementType *res;
    
    for(int i = 0; i < arrSize; i++) {
        if(absVal(getIntVal(arr[i])) > max) {
            max = absVal(getIntVal(arr[i]));
        }
    }

    maxDigitLength = 0;
    while(max) {
        maxDigitLength += 1;
        max /= 10;
    }

    res = (ElementType*)malloc(sizeof(ElementType)*arrSize);
    dev = 1;
    for(int i = 0; i < maxDigitLength; i++) {
        memset(count, 0, sizeof(int)*19);
        for(int j = 0; j < arrSize; j++) {
            radix = getIntVal(arr[j]) / dev % 10;
            count[radix+9] += 1;
        }

        count[0] -= 1;
        for(int j = 1; j < 19; j++) {
            count[j] += count[j-1];
        }

        for(int j = arrSize-1; j >= 0; j--) {
            radix = getIntVal(arr[j]) / dev % 10;
            res[count[getIntVal(arr[j])/dev%10+9]] = arr[j];
            count[getIntVal(arr[j])/dev%10+9] -= 1;
        }

        memcpy(arr, res, sizeof(ElementType)*arrSize);
        dev *= 10;
    }

    free(res);
}

bool containsDuplicate(int* nums, int numsSize){
    bool haveSameEle;

    haveSameEle = false;
    
    radixSort(nums, numsSize, getIntVal);
    for(int i = 1; i < numsSize; i++) {
        if(nums[i] == nums[i-1]) {
            haveSameEle = true;
            break;
        }
    }

    return haveSameEle;
}
```

### 解法二：哈希集合

```c
typedef int ElementType;
typedef int Position;

typedef struct LNode *PtrToLNode;
struct LNode {
    ElementType key;
    PtrToLNode next;
};
typedef PtrToLNode List;

typedef struct {
   List *buckets;
   int size; 
} HashSet;

Position HashFunc(ElementType key) {
	return key % 1000 + 999;
}

HashSet *makeNewHashSet(int size) {
	HashSet *newHashSet;

	newHashSet = (HashSet*)malloc(sizeof(HashSet));
	newHashSet->size = size;
	newHashSet->buckets = (PtrToLNode*)malloc(sizeof(struct ListNode)*size);
	memset(newHashSet->buckets, 0, sizeof(PtrToLNode)*size);

	return newHashSet;
}

bool HashSetContains(HashSet *s, ElementType key) {
	bool isContained;
	PtrToLNode ptr;

	isContained = false;
	ptr = (s->buckets)[HashFunc(key)];

	while(ptr) {
		if(ptr->key == key) {
			isContained = true;
			break;
		}
        ptr = ptr->next;
	}

	return isContained;
}

void HashSetAdd(HashSet *s, ElementType key) {
	PtrToLNode ptr;

	if(!HashSetContains(s, key)) {
		ptr = (s->buckets)[HashFunc(key)];
		(s->buckets)[HashFunc(key)] = (PtrToLNode)malloc(sizeof(struct ListNode));
		(s->buckets)[HashFunc(key)]->key = key;
		(s->buckets)[HashFunc(key)]->next = ptr;
	}
}

void HashSetRemove(HashSet *s, ElementType key) {
	PtrToLNode ptr, tmp;
    
    if(HashSetContains(s, key)) {
        ptr = (s->buckets)[HashFunc(key)];
        if(ptr->key == key) {
            (s->buckets)[HashFunc(key)] = ptr->next;
            free(ptr);
        }
        else {
            tmp = (s->buckets)[HashFunc(key)];
            ptr = ptr->next;
            while(ptr) {
                if(ptr->key == key) {
                    tmp->next = ptr->next;
                    free(ptr);
                    break;
                }
                tmp = ptr;
                ptr = ptr->next;
            }
        }
    }
}

void HashSetFree(HashSet* s) {
    PtrToLNode ptr1, ptr2;
    
    for(int i = 0; i < s->size; i++) {
        if((s->buckets)[i] != NULL) {
            ptr1 = (s->buckets)[i];
            while(ptr1) {
                ptr2 = ptr1->next;
                free(ptr1);
                ptr1 = ptr2;
            }
        }
    }

    free(s);
}

bool containsDuplicate(int* nums, int numsSize){
    HashSet *s;
    bool retVal;

    s = makeNewHashSet(1999);
    retVal = false;

    for(int i = 0; i < numsSize; i++) {
        if(HashSetContains(s, nums[i])) {
            retVal = true;
            break;
        }
        else {
            HashSetAdd(s, nums[i]);
        }
    }

    return retVal;
}
```



## 219.存在重复元素Ⅱ(简单)

https://leetcode.cn/problems/contains-duplicate-ii/description/

```c
typedef int KeyType;
typedef int ValType;
typedef int Position;

typedef struct SetNode *PtrToSetNode;
struct SetNode {
    KeyType key;
    PtrToSetNode next;
};
typedef PtrToSetNode SetList;

typedef struct {
   SetList *buckets;
   int size; 
} HashSet;

Position HashFunc(KeyType key) {
	return key % 1000 + 999;
}

HashSet *makeNewHashSet(int size) {
	HashSet *newHashSet;

	newHashSet = (HashSet*)malloc(sizeof(HashSet));
	newHashSet->size = size;
	newHashSet->buckets = (PtrToSetNode*)malloc(sizeof(struct SetNode)*size);
	memset(newHashSet->buckets, 0, sizeof(PtrToSetNode)*size);

	return newHashSet;
}

bool HashSetContains(HashSet *s, KeyType key) {
	bool isContained;
	PtrToSetNode ptr;

	isContained = false;
	ptr = (s->buckets)[HashFunc(key)];

	while(ptr) {
		if(ptr->key == key) {
			isContained = true;
			break;
		}
        ptr = ptr->next;
	}

	return isContained;
}

void HashSetAdd(HashSet *s, KeyType key) {
	PtrToSetNode ptr;

	if(!HashSetContains(s, key)) {
		ptr = (s->buckets)[HashFunc(key)];
		(s->buckets)[HashFunc(key)] = (PtrToSetNode)malloc(sizeof(struct SetNode));
		(s->buckets)[HashFunc(key)]->key = key;
		(s->buckets)[HashFunc(key)]->next = ptr;
	}
}

void HashSetRemove(HashSet *s, KeyType key) {
	PtrToSetNode ptr, tmp;
    
    if(HashSetContains(s, key)) {
        ptr = (s->buckets)[HashFunc(key)];
        if(ptr->key == key) {
            (s->buckets)[HashFunc(key)] = ptr->next;
            free(ptr);
        }
        else {
            tmp = (s->buckets)[HashFunc(key)];
            ptr = ptr->next;
            while(ptr) {
                if(ptr->key == key) {
                    tmp->next = ptr->next;
                    free(ptr);
                    break;
                }
                tmp = ptr;
                ptr = ptr->next;
            }
        }
    }
}

void HashSetFree(HashSet* s) {
    PtrToSetNode ptr1, ptr2;
    
    for(int i = 0; i < s->size; i++) {
        if((s->buckets)[i] != NULL) {
            ptr1 = (s->buckets)[i];
            while(ptr1) {
                ptr2 = ptr1->next;
                free(ptr1);
                ptr1 = ptr2;
            }
        }
    }

    free(s);
}

bool containsNearbyDuplicate(int* nums, int numsSize, int k){
    HashSet *s;
    int left, right;
    bool retVal;

    s = makeNewHashSet(1999);
    left = 0; right = 1;
    retVal = false;
    while(right < numsSize) {
        if(left == 0) {
            HashSetAdd(s, nums[left]);
            while(right-left <= k && right < numsSize) {
                if(HashSetContains(s, nums[right])) {
                    retVal = true;
                    break;
                }
                HashSetAdd(s, nums[right]);
                right += 1;
            }
            HashSetRemove(s, nums[left]);
            left += 1;
        }
        else {
            if(HashSetContains(s, nums[right])) {
                retVal = true;
                break;
            }
            HashSetAdd(s, nums[right++]);
            HashSetRemove(s, nums[left++]);
        }

        if(retVal) {
            break;
        }
    }

    return retVal;
}
```



## 225.用队列实现栈(简单)

https://leetcode.cn/problems/implement-stack-using-queues/description/

```c
typedef int ElementType;
typedef int Position;

typedef struct {
    ElementType *queueArr;
    Position head, tail;
    int capacity;
} Queue;

Queue *makeNewQueue(int size) {
    Queue *newQueue;

    newQueue = (Queue*)malloc(sizeof(Queue));
    newQueue->queueArr = (ElementType*)malloc(sizeof(ElementType)*(size+1));
    newQueue->capacity = size + 1;
    newQueue->head = newQueue->tail = 0;

    return newQueue;
}

bool isEmptyQueue(Queue *q) {
    return (q->head % q->capacity) == (q->tail % q->capacity);
}

bool isFullQueue(Queue *q) {
    return (q->head % q->capacity) == ((q->tail+1) % q->capacity);
}

void enQueue(Queue *q, ElementType val) {
    if(isFullQueue(q)) {
        printf("Queue is full!\n");
        abort();
    }

    (q->queueArr)[(++(q->tail))%(q->capacity)] = val;
}

ElementType deQueue(Queue *q) {
    if(isEmptyQueue(q)) {
        printf("Queue is empty!\n");
        abort();
    }

    return (q->queueArr)[(++(q->head))%(q->capacity)];
}

ElementType getHeadEle(Queue *q) {
    if(isEmptyQueue(q)) {
        printf("Queue is empty!\n");
        abort();
    }

    return (q->queueArr)[q->head%q->capacity];
}

int elementNumInQueue(Queue *q) {
    int eleNum;
    
    if(q->tail%q->capacity > q->head%q->capacity) {
        eleNum = q->tail%q->capacity - q->head%q->capacity;
    }
    else if(q->tail%q->capacity == q->head%q->capacity) {
        eleNum = 0;
    }
    else {
        eleNum = q->tail%q->capacity - q->head%q->capacity + q->capacity-1;
    }

    return eleNum;
}

void freeQueue(Queue *q) {
    free(q->queueArr);
    free(q);
}

typedef struct {
    Queue *q;
} MyStack;


MyStack* myStackCreate() {
    MyStack *s;

    s = (MyStack*)malloc(sizeof(MyStack));
    s->q = makeNewQueue(100);

    return s;
}

void myStackPush(MyStack* obj, int x) {
    enQueue(obj->q, x);
}

int myStackPop(MyStack* obj) {
    int num;

    num = elementNumInQueue(obj->q);

    for(int i = 0; i < num-1; i++) {
        enQueue(obj->q, deQueue(obj->q));
    }

    return deQueue(obj->q);
}

int myStackTop(MyStack* obj) {
    int num, res;

    num = elementNumInQueue(obj->q);

    for(int i = 0; i < num-1; i++) {
        enQueue(obj->q, deQueue(obj->q));
    }

    res = deQueue(obj->q);
    enQueue(obj->q, res);
    
    return res;
}

bool myStackEmpty(MyStack* obj) {
    return isEmptyQueue(obj->q);
}

void myStackFree(MyStack* obj) {
    freeQueue(obj->q);
    free(obj);
}
```



## 231.2的幂(简单)

https://leetcode.cn/problems/power-of-two/description/

```c
bool isPowerOfTwo(int n) {
    if(n <= 0) {
        return false;
    }
    else {
        return (n & (n-1)) == 0 ? true : false;
    }

}
```

注意运算的优先级。



## 232.用栈实现队列

https://leetcode.cn/problems/implement-queue-using-stacks/description/

```c
typedef int ElementType;
typedef int Position;

typedef struct {
    ElementType *stackArr;
    Position top;
    int capacity;
} Stack;

Stack *makeNewStack(int size) {
    Stack *newStack;

    newStack = (Stack*)malloc(sizeof(Stack));
    newStack->top = -1;
    newStack->stackArr = (ElementType*)malloc(sizeof(ElementType)*size);
    newStack->capacity = size;

    return newStack;
}

bool isEmptyStack(Stack *s) {
    return s->top == -1;
}

bool isFullStack(Stack *s) {
    return s->top + 1 == s->capacity;
}

void push(Stack *s, ElementType val) {
    if(!isFullStack(s)) {
        (s->stackArr)[++s->top] = val;
    }
    else {
        printf("Stack is full!\n");
        abort();
    }
}

ElementType pop(Stack *s) {
    if(isEmptyStack(s)) {
        printf("Stack is empty!\n");
        abort();
    }
    
    return (s->stackArr)[(s->top)--];
}

ElementType getTopEle(Stack *s) {
    if(isEmptyStack(s)) {
        printf("Stack is empty!\n");
        abort();
    }
    
    return (s->stackArr)[s->top];
}

void freeStack(Stack *s) {
    free(s->stackArr);
    free(s);
}

typedef struct {
    Stack *s1, *s2;
} MyQueue;


MyQueue* myQueueCreate() {
    MyQueue *q;

    q = (MyQueue*)malloc(sizeof(MyQueue));
    q->s1 = makeNewStack(100);
    q->s2 = makeNewStack(100);

    return q;
}

void myQueuePush(MyQueue* obj, int x) {
    push(obj->s1, x);
}

int myQueuePop(MyQueue* obj) {
    int res;

    while(!isEmptyStack(obj->s1)) {
        push(obj->s2, pop(obj->s1));
    }

    res = pop(obj->s2);

    while(!isEmptyStack(obj->s2)) {
        push(obj->s1, pop(obj->s2));
    }

    return res;
}

int myQueuePeek(MyQueue* obj) {
    int res;

    while(!isEmptyStack(obj->s1)) {
        push(obj->s2, pop(obj->s1));
    }

    res = pop(obj->s2);
    push(obj->s2, res);

    while(!isEmptyStack(obj->s2)) {
        push(obj->s1, pop(obj->s2));
    }

    return res;
}

bool myQueueEmpty(MyQueue* obj) {
    return isEmptyStack(obj->s1);
}

void myQueueFree(MyQueue* obj) {
    free(obj->s1);
    free(obj->s2);
    free(obj);
}
```



## 235.二叉搜索树的最近公共祖先(中等)

https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/description/

```c
int nodeIsInTree(struct TreeNode* root, int val) {
    int retVal;

    retVal = 0;
    
    if(root) {
        if(root->val == val) {
            retVal = 1;
        }
        else if(root->left && root->right) {
            retVal = nodeIsInTree(root->left, val) || nodeIsInTree(root->right, val);
        }
        else if(root->left) {
            retVal = nodeIsInTree(root->left, val);
        }
        else if(root->right) {
            retVal = nodeIsInTree(root->right, val);
        }
    }

    return retVal;
}

struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {
    struct TreeNode *retVal;

    if(root->val == p->val || root->val == q->val) {
        retVal = root;
    }
    else if(root->left && root->right) {
        int pIsInLeft, qIsInLeft;

        pIsInLeft = nodeIsInTree(root->left, p->val);
        qIsInLeft = nodeIsInTree(root->left, q->val);

        if(pIsInLeft == qIsInLeft) {
            if(pIsInLeft) {
                retVal = lowestCommonAncestor(root->left, p, q);
            }
            else {
                retVal = lowestCommonAncestor(root->right, p, q);
            }
        }
        else {
            retVal = root;
        }
    }
    else if(root->left) {
        retVal = lowestCommonAncestor(root->left, p, q);
    }
    else if(root->right) {
        retVal = lowestCommonAncestor(root->right, p, q);
    }

    return retVal;
}
```



## 236.二叉树的最近公共祖先(中等)

https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/

```c
int nodeIsInTree(struct TreeNode* root, int val) {
    int retVal;

    retVal = 0;
    
    if(root) {
        if(root->val == val) {
            retVal = 1;
        }
        else if(root->left && root->right) {
            retVal = nodeIsInTree(root->left, val) || nodeIsInTree(root->right, val);
        }
        else if(root->left) {
            retVal = nodeIsInTree(root->left, val);
        }
        else if(root->right) {
            retVal = nodeIsInTree(root->right, val);
        }
    }

    return retVal;
}

struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {
    struct TreeNode *retVal;

    if(root->val == p->val || root->val == q->val) {
        retVal = root;
    }
    else if(root->left && root->right) {
        int pIsInLeft, qIsInLeft;

        pIsInLeft = nodeIsInTree(root->left, p->val);
        qIsInLeft = nodeIsInTree(root->left, q->val);

        if(pIsInLeft == qIsInLeft) {
            if(pIsInLeft) {
                retVal = lowestCommonAncestor(root->left, p, q);
            }
            else {
                retVal = lowestCommonAncestor(root->right, p, q);
            }
        }
        else {
            retVal = root;
        }
    }
    else if(root->left) {
        retVal = lowestCommonAncestor(root->left, p, q);
    }
    else if(root->right) {
        retVal = lowestCommonAncestor(root->right, p, q);
    }

    return retVal;
}
```



## 263.丑数(简单)

https://leetcode.cn/problems/ugly-number/description/

```c
bool isUgly(int n){
    bool is_ugly;

    is_ugly = false;

    if(n > 0) {
        while(n % 2 == 0) {
            n /= 2;
        }

        while(n % 3 == 0) {
            n /= 3;
        }

        while(n % 5 == 0) {
            n /= 5;
        }

        is_ugly = (n == 1);
    }

    return is_ugly;
}
```



## 268.丢失的数字(简单)

https://leetcode.cn/problems/missing-number/description/

```c
int missingNumber(int* nums, int numsSize){
    int *hash_table, mis_num;

    hash_table = (int*)malloc(sizeof(int)*(numsSize+1));
    for(int i = 0; i <= numsSize; i++) {
        hash_table[i] = 0;
    }

    for(int i = 0; i < numsSize; i++) {
        hash_table[nums[i]] += 1;
    }

    for(int i = 0; i <= numsSize; i++) {
        if(hash_table[i] == 0) {
            mis_num = i;
            break;
        }
    }

    return mis_num;
}
```



## 278.第一个错误的版本(简单)

https://leetcode.cn/problems/first-bad-version/description/

```c
int firstBadVersion(int n) {
    int left, right, mid, retVal;

    left = 1;
    right = n;

    if(isBadVersion(1))
        retVal = 1;
    else {
        while(left <= right) {
            mid = (right - left) / 2 + left;

            if(!isBadVersion(mid))
                left = mid + 1;
            else {
                if(!isBadVersion(mid-1)) {
                    retVal = mid;

                    break;
                }
                else
                    right = mid - 1;
            }
        }
    }

    return retVal;
}
```

需要注意，我们通过下方的代码来避免溢出：

```c
mid = (right - left) / 2 + left;
```

而不采用：

```c
mid = (left + right) / 2;
```



## 279.完全平方数(中等)

https://leetcode.cn/problems/perfect-squares/description/

```c
typedef short ElementType;
typedef int Position;

typedef struct {
    ElementType *queueArr;
    Position head, tail;
    int capacity;
} Queue;

Queue *makeNewQueue(int size) {
    Queue *newQueue;

    newQueue = (Queue*)malloc(sizeof(Queue));
    newQueue->queueArr = (ElementType*)malloc(sizeof(ElementType)*size);
    newQueue->capacity = size + 1;
    newQueue->head = newQueue->tail = 0;

    return newQueue;
}

bool isEmptyQueue(Queue *q) {
    return (q->head % q->capacity) == (q->tail % q->capacity);
}

bool isFullQueue(Queue *q) {
    return (q->head % q->capacity) == ((q->tail+1) % q->capacity);
}

void enQueue(Queue *q, ElementType val) {
    if(isFullQueue(q)) {
        printf("Queue is full!\n");
        abort();
    }

    (q->queueArr)[(q->tail+1)%(q->capacity)] = val;
    q->tail += 1;
}

ElementType deQueue(Queue *q) {
    if(isEmptyQueue(q)) {
        printf("Queue is empty!\n");
        abort();
    }

    return (q->queueArr)[(++(q->head))%(q->capacity)];
}

ElementType getHeadEle(Queue *q) {
    if(isEmptyQueue(q)) {
        printf("Queue is empty!\n");
        abort();
    }

    return (q->queueArr)[q->head%q->capacity];
}

int elementNumInQueue(Queue *q) {
    int eleNum;
    
    if(q->tail%q->capacity > q->head%q->capacity) {
        eleNum = q->tail%q->capacity - q->head%q->capacity;
    }
    else if(q->tail%q->capacity == q->head%q->capacity) {
        eleNum = 0;
    }
    else {
        eleNum = q->tail%q->capacity - q->head%q->capacity + q->capacity-1;
    }

    return eleNum;
}

void freeQueue(Queue *q) {
    free(q->queueArr);
    free(q);
}

int numSquares(int n) {
    Queue *q;
    int step, num, numInQueue;

    q = makeNewQueue(n*n/3+10);

    step = 0;

    enQueue(q, n);
    while(!isEmptyQueue(q)) {
        numInQueue = elementNumInQueue(q); 

        for(int i = 0; i < numInQueue; i++) {
            num = deQueue(q);

            if(num == 0) {
                freeQueue(q);
                return step;
            }

            for(int i = sqrt(num); i > 0; i--) {
                enQueue(q, num-i*i);
            }
        }

        step += 1;
    }

    freeQueue(q);

    return -1;
}
```

BFS算法求解最短路问题，在图较复杂时开销较大



## 283.移动零(简单)

https://leetcode.cn/problems/move-zeroes/description/

```c
void moveZeroes(int* nums, int numsSize) {
    bool swapped;
    int indexOfLastUnsortedEle, swapIndex;

    swapped = true;
    indexOfLastUnsortedEle = numsSize - 1;
    swapIndex = -1;

    while(swapped) {
        swapped = false;

        for(int i = 0; i < indexOfLastUnsortedEle; i++) {
            if(nums[i] == 0 && nums[i+1] != 0) {
                nums[i] = nums[i] ^ nums[i+1];
                nums[i+1] = nums[i] ^ nums[i+1];
                nums[i] = nums[i+1] ^ nums[i];

                swapped = true;
                swapIndex = i;
            }
        }

        indexOfLastUnsortedEle = swapIndex;
    }
}
```



## 286.墙与门(中等)

https://leetcode.cn/problems/walls-and-gates/description/

```c
typedef struct {
    int col, row;
} Point;

typedef Point ElementType;
typedef int Position;

typedef struct {
    ElementType *queueArr;
    Position head, tail;
    int capacity;
} Queue;

Queue *makeNewQueue(int size) {
    Queue *newQueue;

    newQueue = (Queue*)malloc(sizeof(Queue));
    newQueue->queueArr = (ElementType*)malloc(sizeof(ElementType)*(size+1));
    newQueue->capacity = size + 1;
    newQueue->head = newQueue->tail = 0;

    return newQueue;
}

bool isEmptyQueue(Queue *q) {
    return (q->head % q->capacity) == (q->tail % q->capacity);
}

bool isFullQueue(Queue *q) {
    return (q->head % q->capacity) == ((q->tail+1) % q->capacity);
}

void enQueue(Queue *q, ElementType val) {
    if(isFullQueue(q)) {
        printf("Queue is full!\n");
        abort();
    }

    (q->queueArr)[(++(q->tail))%(q->capacity)] = val;
}

ElementType deQueue(Queue *q) {
    if(isEmptyQueue(q)) {
        printf("Queue is empty!\n");
        abort();
    }

    return (q->queueArr)[(++(q->head))%(q->capacity)];
}

ElementType getHeadEle(Queue *q) {
    if(isEmptyQueue(q)) {
        printf("Queue is empty!\n");
        abort();
    }

    return (q->queueArr)[q->head%q->capacity];
}

int elementNumInQueue(Queue *q) {
    int eleNum;
    
    if(q->tail%q->capacity > q->head%q->capacity) {
        eleNum = q->tail%q->capacity - q->head%q->capacity;
    }
    else if(q->tail%q->capacity == q->head%q->capacity) {
        eleNum = 0;
    }
    else {
        eleNum = q->tail%q->capacity - q->head%q->capacity + q->capacity-1;
    }

    return eleNum;
}

void freeQueue(Queue *q) {
    free(q->queueArr);
    free(q);
}

void wallsAndGates(int** rooms, int roomsSize, int* roomsColSize){
    bool **havePassed;
    int step, numInQueue;
    Queue *q;
    Point p, p_new;

    havePassed = (bool**)malloc(sizeof(bool*)*roomsSize);
    for(int i = 0; i < roomsSize; i++) {
        havePassed[i] = (bool*)malloc(sizeof(bool)*roomsColSize[i]);
    }

    for(int i = 0; i < roomsSize; i++) {
        for(int j = 0; j < roomsColSize[i]; j++) {
            if(rooms[i][j] == 0) {

                for(int i = 0; i < roomsSize; i++) {
                    for(int j = 0; j < roomsColSize[i]; j++) {
                        havePassed[i][j] = false;
                    }
                }

                q = makeNewQueue(roomsSize*roomsColSize[i]);

                step = 0;

                p.col = i;
                p.row = j;
                havePassed[i][j] = true;
                enQueue(q, p);
                while(!isEmptyQueue(q)) {
                    numInQueue = elementNumInQueue(q);

                    for(int k = 0; k < numInQueue; k++) {
                        p = deQueue(q);
                        if(step < rooms[p.col][p.row]) {
                            rooms[p.col][p.row] = step;
                        }

                        if(p.col-1 >= 0 && rooms[p.col-1][p.row] > 0 && havePassed[p.col-1][p.row] == false) {
                            havePassed[p.col-1][p.row] = true;
                            p_new.col = p.col-1;
                            p_new.row = p.row;
                            enQueue(q, p_new);
                        }
                        if(p.row-1 >= 0 && rooms[p.col][p.row-1] > 0 && havePassed[p.col][p.row-1] == false) {
                            havePassed[p.col][p.row-1] = true;
                            p_new.col = p.col;
                            p_new.row = p.row-1;
                            enQueue(q, p_new);
                        }
                        if(p.col+1 < roomsSize && rooms[p.col+1][p.row] > 0 && havePassed[p.col+1][p.row] == false) {
                            havePassed[p.col+1][p.row] = true;
                            p_new.col = p.col+1;
                            p_new.row = p.row;
                            enQueue(q, p_new);
                        }
                        if(p.row+1 < roomsColSize[0] && rooms[p.col][p.row+1] > 0 && havePassed[p.col][p.row+1] == false) {
                            havePassed[p.col][p.row+1] = true;
                            p_new.col = p.col;
                            p_new.row = p.row+1;
                            enQueue(q, p_new);
                        }
                    }

                    step += 1;
                }

                freeQueue(q);
            }
        }
    }
}
```



## 297.二叉树的序列化与反序列化

https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/description/

```c
typedef struct TreeNode* ElementType;
typedef int Position;

typedef struct {
    ElementType *queueArr;
    Position head, tail;
    int capacity;
} Queue;

Queue *makeNewQueue(int size) {
    Queue *newQueue;

    newQueue = (Queue*)malloc(sizeof(Queue));
    newQueue->queueArr = (ElementType*)malloc(sizeof(ElementType)*(size+1));
    newQueue->capacity = size + 1;
    newQueue->head = newQueue->tail = 0;

    return newQueue;
}

bool isEmptyQueue(Queue *q) {
    return (q->head % q->capacity) == (q->tail % q->capacity);
}

bool isFullQueue(Queue *q) {
    return (q->head % q->capacity) == ((q->tail+1) % q->capacity);
}

void enQueue(Queue *q, ElementType val) {
    if(isFullQueue(q)) {
        printf("Queue is full!\n");
        abort();
    }

    (q->queueArr)[(++(q->tail))%(q->capacity)] = val;
}

ElementType deQueue(Queue *q) {
    if(isEmptyQueue(q)) {
        printf("Queue is empty!\n");
        abort();
    }

    return (q->queueArr)[(++(q->head))%(q->capacity)];
}

ElementType getHeadEle(Queue *q) {
    if(isEmptyQueue(q)) {
        printf("Queue is empty!\n");
        abort();
    }

    return (q->queueArr)[q->head%q->capacity];
}

int elementNumInQueue(Queue *q) {
    int eleNum;
    
    if(q->tail%q->capacity > q->head%q->capacity) {
        eleNum = q->tail%q->capacity - q->head%q->capacity;
    }
    else if(q->tail%q->capacity == q->head%q->capacity) {
        eleNum = 0;
    }
    else {
        eleNum = q->tail%q->capacity - q->head%q->capacity + q->capacity-1;
    }

    return eleNum;
}

void freeQueue(Queue *q) {
    free(q->queueArr);
    free(q);
}

void nodeCount(struct TreeNode *root, int *node_count) {
    if(root) {
        *node_count += 1;

        nodeCount(root->left, node_count);
        nodeCount(root->right, node_count);
    }
}

void preTraverse(struct TreeNode *root, int *preSeq, int *index) {
    if(root) {
        preSeq[*index] = root->val;
        *index += 1;
        preTraverse(root->left, preSeq, index);
        preTraverse(root->right, preSeq, index);
    }
}

void inTraverse(struct TreeNode *root, int *inSeq, int *index) {
    if(root) {
        inTraverse(root->left, inSeq, index);
        inSeq[*index] = root->val;
        *index += 1;
        inTraverse(root->right, inSeq, index);
    }
}

struct TreeNode* buildTree(int* preorder, int preorderSize, int* inorder, int inorderSize) {
    struct TreeNode *root;
    int index;
    int *left_preorder, *right_preorder, *left_inorder, *right_inorder;

    root = NULL;
    
    if(preorderSize > 0) {
        root = (struct TreeNode*)malloc(sizeof(struct TreeNode));
        root->val = preorder[0];

        for(int i = 0; i < inorderSize; i++) {
            if(inorder[i] == preorder[0]) {
                index = i;
                break;
            }
        }

        left_preorder = (int*)malloc(sizeof(int)*index);
        left_inorder = (int*)malloc(sizeof(int)*index);
        right_preorder = (int*)malloc(sizeof(int)*(inorderSize-index-1));
        right_inorder = (int*)malloc(sizeof(int)*(inorderSize-index-1));

        for(int i = 0; i < index; i++) {
            left_inorder[i] = inorder[i];
            left_preorder[i] = preorder[1+i];
        }

        for(int i = 0; i < inorderSize-index-1; i++) {
            right_inorder[i] = inorder[index+1+i];
            right_preorder[i] = preorder[index+1+i];
        }

        root->left = buildTree(left_preorder, index, left_inorder, index);
        root->right = buildTree(right_preorder, inorderSize-index-1, right_inorder, inorderSize-index-1);
    }

    return root;
}

int Map[10000];

char* serialize(struct TreeNode* root) {
    int node_count, *preSeq, *inSeq, index, map_index;
    char *retVal;
    Queue *q;
    struct TreeNode *ptr;

    node_count = 0;
    nodeCount(root, &node_count);

    if(node_count > 0) {
        q = makeNewQueue(node_count);

        map_index = 0;
        enQueue(q, root);
        while(!isEmptyQueue(q)) {
            ptr = deQueue(q);

            Map[map_index] = ptr->val;
            ptr->val = map_index++;
            if(ptr->left) {
                enQueue(q, ptr->left);
            }
            if(ptr->right) {
                enQueue(q, ptr->right);
            }
        }
        freeQueue(q);
    }

    preSeq = (int*)malloc(sizeof(int)*node_count);
    inSeq = (int*)malloc(sizeof(int)*node_count);

    index = 0;
    preTraverse(root, preSeq, &index);
    index = 0;
    inTraverse(root, inSeq, &index);

    retVal = (char*)malloc(sizeof(int)*(node_count*2+1));
    memcpy(&retVal[sizeof(int)], preSeq, sizeof(int)*node_count);
    memcpy(&retVal[sizeof(int)*(node_count+1)], inSeq, sizeof(int)*node_count);
    memcpy(retVal, &node_count, sizeof(int));

    free(preSeq);
    free(inSeq);

    return retVal;
}

struct TreeNode* deserialize(char* data) {
    int seq_len, *preSeq, *inSeq, index;
    struct TreeNode *root, *ptr;
    Queue *q;

    memcpy(&seq_len, data, sizeof(int));

    preSeq = (int*)malloc(sizeof(int)*seq_len);
    memcpy(preSeq, &data[sizeof(int)], sizeof(int)*seq_len);
    inSeq = (int*)malloc(sizeof(int)*seq_len);
    memcpy(inSeq, &data[sizeof(int)*(seq_len+1)], sizeof(int)*seq_len);

    root = buildTree(preSeq, seq_len, inSeq, seq_len);

    free(preSeq);
    free(inSeq);

    if(root) {
        q = makeNewQueue(seq_len);
        index = 0;

        enQueue(q, root);
        while(!isEmptyQueue(q)) {
            ptr = deQueue(q);
            ptr->val = Map[index++];

            if(ptr->left) {
                enQueue(q, ptr->left);
            }
            if(ptr->right) {
                enQueue(q, ptr->right);
            }
        }

        free(q);
    }

    return root;
}
```

