# LeetCode 901-1000



## 908.最小差值Ⅰ(简单)

https://leetcode.cn/problems/smallest-range-i/description/

```c
int smallestRangeI(int* nums, int numsSize, int k){
    int max, min;

    max = min = nums[0];
    for(int i = 0; i < numsSize; i++) {
        if(nums[i] > max) {
            max = nums[i];
        }
        else if(nums[i] < min) {
            min = nums[i];
        }
    }

    return max-min > 2*k ? max-min-2*k : 0;
}
```



## 912.排序数组(中等)

https://leetcode.cn/problems/sort-an-array/description/

### 解法一：Knuth增量下的希尔排序

```c
void shellSort(int *arr, int size) {
    int gap;
    
    gap = 1;
    while(gap < size/3) {
        gap = gap * 3 + 1;
    }
    
    while(gap > 0) {
        for(int i = gap; i < size; i++) {
            int currentNum, index;
            
            currentNum = arr[i];
            index = i - gap;
            while(index >= 0 && arr[index] > currentNum) {
                arr[index+gap] = arr[index];
                index -= gap;
            }
            arr[index+gap] = currentNum;
        }
        gap = (gap - 1) / 3;
    }
}

int* sortArray(int* nums, int numsSize, int* returnSize) {
    shellSort(nums, numsSize);

    *returnSize = numsSize;

    return nums;
}
```

### 解法二：堆排序

```c
void swap(int *arr, int i, int j) {
    int tmp;
    
    tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

void maxHeapify(int *arr, int size, int index) {
    int max_index, left, right;
    
    max_index = index;
    left = (index << 1) + 1;
    right = left + 1;
    
	max_index = left < size && arr[left] > arr[max_index] ? left : max_index;
    max_index = right < size && arr[right] > arr[max_index] ? right : max_index;
    
    if(max_index != index) {
        swap(arr, index, max_index);
        maxHeapify(arr, size, max_index);
        // 递归，保证子树还是最大堆
    }  
}

void buildMaxHeap(int *arr, int size) {
    for(int i = (size >> 1) - 1; i >= 0; i--) {
        maxHeapify(arr, size, i);
    }
}

void heapSort(int *arr, int size) {
    buildMaxHeap(arr, size);
    
    for(int i = 0; i < size; i++) {
        swap(arr, 0, size-1-i);
        maxHeapify(arr, size-1-i, 0);
    }
}

int* sortArray(int* nums, int numsSize, int* returnSize) {
    heapSort(nums, numsSize);

    *returnSize = numsSize;

    return nums;
}
```

### 解法三：归并排序

```c
void merge(int *arr, int start, int end, int *res) {
    int end1, start2, ptr1, ptr2, ptr;
    
    end1 = (end-start) / 2 + start;
    start2 = end1 + 1;
    
    ptr = ptr1 = start; ptr2 = start2;
    while(ptr1 <= end1 || ptr2 <= end) {
        if(ptr1 <= end1 && ptr2 <= end) {
            if(arr[ptr1] <= arr[ptr2]) {
                res[ptr++] = arr[ptr1++];
            }
            else {
                res[ptr++] = arr[ptr2++];
            }
        }
        else if(ptr1 <= end1) {
            res[ptr++] = arr[ptr1++];
        }
        else {
            res[ptr++] = arr[ptr2++];
        }
    }
    
    for(ptr = start; ptr <= end; ptr++) {
        arr[ptr] = res[ptr];
    }
}

void MergeSort(int *arr, int start, int end, int *res) {
    int mid;
    
    if(end > start) {
        mid = (end-start) / 2 + start;
        
        MergeSort(arr, start, mid, res);
        MergeSort(arr, mid+1, end, res);
        
        merge(arr, start, end, res);
    }
}

void mergeSort(int *arr, int size) {
    int *res;
    
    if(size <= 1) {
        return ;
    }
    
    res = (int*)malloc(sizeof(int)*size);
    
    MergeSort(arr, 0, size-1, res);

    free(res);
}

int* sortArray(int* nums, int numsSize, int* returnSize) {
    mergeSort(nums, numsSize);

    *returnSize = numsSize;

    return nums;
}
```

### 解法四：快速排序

```c
typedef int ElementType;
typedef int Position;

int compare(ElementType a, ElementType b) {
    int retVal;
    
    if(a < b) {
        retVal = -1;
    }
    else if(a == b) {
        retVal = 0;
    }
    else {
        retVal = 1;
    }

    return retVal;
}

ElementType partition(ElementType *arr, Position start, Position end, int (*compare)(ElementType a, ElementType b)) {
    int pivot;
    Position left, right, random_index;
    ElementType tmp;

    random_index = start + rand()%(end-start+1);
    tmp = arr[start];
    arr[start] = arr[random_index];
    arr[random_index] = tmp;


    pivot = arr[start];
    left = start + 1;
    right = end;

    while(left < right) {
        while(left < right && compare(arr[left], pivot) <= 0) {
            left += 1;
        }

        while(right > left && compare(arr[right], pivot) >= 0) {
            right -= 1;
        }

        if(left != right) {
            tmp = arr[left];
            arr[left] = arr[right];
            arr[right] = tmp;

            right -= 1;
            left += 1;
        }
    }

    if(left == right && compare(arr[right], pivot) > 0) {
        right -= 1;
    }

    tmp = arr[start];
    arr[start] = arr[right];
    arr[right] = tmp;

    return right;
}

void QuickSort(ElementType *arr, Position start, Position end, int (*compare)(ElementType a, ElementType b)) {
    int mid;

    if(start < end) {
        mid = partition(arr, start, end, compare);

        QuickSort(arr, start, mid-1, compare);
        QuickSort(arr, mid+1, end, compare);
    }
}

void quickSort(ElementType *arr, int arrSize, int (*compare)(ElementType a, ElementType b)) { 
    bool isSorted, isReversed;
    ElementType tmp;
    
    srand(time(NULL));
    
    if(arrSize >= 10000) {
        
        isSorted = isReversed = true;

        for(int i = 1; i < arrSize; i++) {
            if(arr[i] < arr[i-1]) {
                isSorted = false;
            }
            if(arr[i] > arr[i-1]) {
                isReversed = false;
            }

            if(!isReversed && !isSorted) {
                break;
            }
        }

        if(isReversed) {
            for(int i = 0; i < arrSize/2; i++) {
                tmp = arr[i];
                arr[i] = arr[arrSize-1-i];
                arr[arrSize-1-i] = tmp;
            }
        }
        else if(!isReversed && !isSorted) {
            QuickSort(arr, 0, arrSize-1, compare);
        }
    }
    else {
        QuickSort(arr, 0, arrSize-1, compare);
    }
}

int* sortArray(int* nums, int numsSize, int* returnSize) {
    quickSort(nums, numsSize, compare);

    *returnSize = numsSize;

    return nums;
}
```

### 解法五：计数排序

```c
typedef int ElementType;

int getIntVal(ElementType a) {
    return a;
}

void countingSort(ElementType *arr, int arrSize, int(*getIntVal)(ElementType a)) {
    int max, min, *count, *res;

    max = min = getIntVal(arr[0]);
    for(int i = 0; i < arrSize; i++) {
        if(getIntVal(arr[i]) > max) {
            max = getIntVal(arr[i]);
        }
        if(getIntVal(arr[i]) < min) {
            min = getIntVal(arr[i]);
        }
    }

    count = (int*)malloc(sizeof(int)*(max-min+1));
    memset(count, 0, sizeof(int)*(max-min+1));

    for(int i = 0; i < arrSize; i++) {
        count[getIntVal(arr[i])-min] += 1;
    }

    count[0] -= 1;
    for(int i = 1; i < max-min+1; i++) {
        count[i] += count[i-1];
    }

    res = (int*)malloc(sizeof(ElementType)*arrSize);
    for(int i = arrSize-1; i >= 0; i--) {
        res[count[getIntVal(arr[i])-min]] = arr[i];
        count[getIntVal(arr[i])-min] -= 1;
    }

    for(int i = 0; i < arrSize; i++) {
        arr[i] = res[i];
    }

    free(res);
    free(count);
}

int* sortArray(int* nums, int numsSize, int* returnSize) {
    countingSort(nums, numsSize, getIntVal);

    *returnSize = numsSize;

    return nums;
}
```

