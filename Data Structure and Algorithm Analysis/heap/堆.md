# 堆 Heap



## 优先队列

> 优先队列是计算机科学中的一类抽象数据类型。优先队列中的每个元素都有各自的优先级，优先级最高的元素最先得到服务；优先级相同的元素按照其在优先队列中的顺序得到服务

可以看到在wiki的定义中，优先队列是一种抽象的数据类型，实现这个抽象数据类型的方式有很多，如数组或链表，但对于插入和删除操作，两种数据类型都只能能保证其中之一的时间复杂度是$O(1)$，另一个则是$O(n)$

堆也是优先队列的一种实现方式，可以保证插入和删除操作的时间复杂度均为$O(n)$



## 堆的基本概念

> 堆是一种特别的二叉树，满足以下条件的二叉树，可以称为堆：
>
> 1. 完全二叉树
> 2. 每个节点的值必须大于等于或小于等于其孩子节点的值

堆具有如下特点：

1. 可以在$O(logn)$的时间复杂度下向堆中插入新元素
2. 可以在$O(logn)$的时间复杂度下删除堆中的某元素
3. 可以在$O(1)$的时间复杂度下取出最大值或最小值

相应的有两种堆：

- 最大堆：堆中每个节点的值都大于等于其孩子节点的值，即堆顶元素最大
- 最小堆：堆中每个节点的值都小于等于其孩子节点的值，即堆顶元素最小



## 堆的基本操作

### 插入

> 向堆中插入一个元素，插入后仍需维持堆的特性

新插入元素需要保持完全二叉树的特性，并将其放置在最后一个节点的位置，逐步向上访问，以保证堆的特性

时间复杂度为$O(n)$

### 删除

> 删除对顶元素，删除后仍需维持堆的特性

删除后将最后一个元素移至堆顶，逐步向下访问（最小堆选取**较小**的节点向下访问，最大堆选取**较大**的节点），不断交换直至满足堆的定义

### 堆的实现

堆可以使用数组进行实现，若使用索引从$1$开始，则有如下关系：

> 若某节点索引为$i$，则其父节点为$\frac{i}{2}$，左孩子为$2i$，右孩子为$2i+1$
>
> 若树中共有n个节点，则其叶节点索引满足$i>\frac{n}{2}$

*在堆排序中为了排序的便捷性也会使用索引从$0$开始，但相应的计算步骤会增多

### 创建堆

创建堆是指初始化一个堆实例，一种最简单的想法是将堆中元素一个个插入，但这样的时间复杂度为$O(nlogn)$，而堆化操作可以在时间复杂度为$O(n)$的条件下实现，具体方法是：

**从第一个非叶节点开始，依次保证该节点及其子节点的集合为一个（最大或最小）堆**



## 堆的应用

### 堆排序

时间复杂度为$O(nlogn)$的排序算法，有两种实现：

- 借助$O(n)$的额外空间，最小堆用于升序排列，最大堆用于降序排列
- 不借助额外空间，最大堆用于升序排列

后者更优，但需要索引从$1$开始

### Top K问题

> 利用堆的数据结构获取Top K大的元素或者Top K小的元素

#### 解法一

Top K大为例，流程如下：

- 建立最大堆
- 删除栈顶元素，并将其保存在额外的集合T中
- 重复上一步骤K次

时间复杂度为$O(KlongN)$，空间复杂度为$O(N)$

#### 解法二

Top K小为例，流程如下：

- 建立最大空堆，并将前$K$个元素加入到堆中
- 从第$K+1$个元素开始遍历，如果元素大于等于堆顶元素直接放弃，删除堆顶元素将新元素加入到堆中
- 重复上述步骤，直到所有元素遍历完
- 最大堆中存储的$K$个元素就是$K$个最小的元素

时间复杂度为$O(NlogK)$，空间复杂度为$O(K)$

### The Kth问题

#### 解法一

以第K大为例，流程如下：

- 将元素进行堆化
- 删除堆顶元素
- 重复上一步骤K次，得到第$K$大的数

时间复杂度为$O(KlogN)$，空间复杂度为$O(N)$

#### 解法二

以第K小为例，流程如下：

- 将前$K$个元素加入到堆中
- 从第$K+1$个元素开始遍历，若大于堆顶元素忽略不管，小于堆顶元素加入到堆中
- 重复上述步骤，直至完全遍历
- 堆顶元素即为第$K$小的元素

时间复杂度为$O(NlogK)$，空间复杂度为$O(K)$



